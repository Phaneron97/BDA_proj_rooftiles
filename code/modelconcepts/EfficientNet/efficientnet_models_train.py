# -*- coding: utf-8 -*-
"""efficientnet_models_train.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CVgrf2SzJYhR_q8gzc7gW1p-zt_YiTHz
"""

learning_rate = 0.001
number_of_train_epochs = 20

model_name = "efficientnet_b7" # efficientnet_b{0-7}
# Define dataset and data loaders
pathToDateset = '/content/drive/MyDrive/MinorBigData/Project/dataset_sample' # 'dataset_sample' 'dataset_all'
side_to_use = 'b'
folders_to_use_train = f'{pathToDateset}/train/{side_to_use}/'
folders_to_use_test = f'{pathToDateset}/test/{side_to_use}/'

# %% imports
import torch
import torchvision
import torchvision.transforms as transforms
import torch.nn as nn
import torch.optim as optim
from torch.utils.data import DataLoader, Dataset
import os
from PIL import Image
import matplotlib.pyplot as plt
from sklearn.metrics import confusion_matrix
import numpy as np
import seaborn as sns

# %% Find label from index
def find_label_from_index(class_lengths, index):
    total = sum(class_lengths)
    current_index = 0

    for i, group_size in enumerate(class_lengths):
        if index < current_index + group_size:
            # returns (class index, image index in the class)
            return i, index - current_index
        current_index += group_size

    # If the index is out of range, return -1, -1
    return -1, -1

# %% dataset class
# Define dataset class
class RooftileDataset(Dataset):
    def __init__(self, root_dir, transform=None):
        self.root_dir = root_dir
        self.folders = os.listdir(root_dir)
        self.transform = transform
        self.classes = sorted(self.folders)

        self.class_images = []
        self.class_lengths = []
        self.total_images = 0
        for class_folder in self.folders:
            class_path = os.path.join(self.root_dir, class_folder)
            class_files = os.listdir(class_path)
            self.class_images.append({
                'class_folder': class_folder,
                'images': class_files
            })
            self.class_lengths.append(len(class_files))
            print(f'Read {len(class_files)} from {class_folder}')
            self.total_images += len(class_files)

    def __len__(self):
        return self.total_images

    def __getitem__(self, idx):
        class_idx, image_idx = find_label_from_index(self.class_lengths, idx)
        selected_class = self.class_images[class_idx]
        class_path = os.path.join(self.root_dir, selected_class['class_folder'])
        img_name = selected_class['images'][image_idx]
        img_path = os.path.join(class_path, img_name)
        # image = torchvision.io.read_image(img_path)
        image = Image.open(img_path).convert("RGB")
        label = class_idx
        if self.transform:
            image = self.transform(image)
        return image, label

# %% creating train and test datasets
# Define transformations
transform = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.ToTensor(),
    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
])

dataset_train = RooftileDataset(root_dir=folders_to_use_train, transform=transform)
dataset_test = RooftileDataset(root_dir=folders_to_use_test, transform=transform)

train_loader = DataLoader(dataset_train, batch_size=32, shuffle=True)
test_loader = DataLoader(dataset_test, batch_size=32, shuffle=False)

num_classes = len(dataset_train.classes)

print(f'Number of classes={num_classes}, number of train={len(dataset_train)}, number of test={len(dataset_test)}')
print(f'Train classes lengths = {dataset_train.class_lengths}')
print(f'Test classes lengths = {dataset_test.class_lengths}')

# efficientnet_b{0-7} available.
def model_creator(model_name, num_classes, freeze_conv_layers=True):
  if model_name == "efficientnet_b0":
    model = torchvision.models.efficientnet_b0(pretrained=True, progress=True)
  if model_name == "efficientnet_b1":
    model = torchvision.models.efficientnet_b1(pretrained=True, progress=True)
  if model_name == "efficientnet_b2":
    model = torchvision.models.efficientnet_b2(pretrained=True, progress=True)
  if model_name == "efficientnet_b3":
    model = torchvision.models.efficientnet_b3(pretrained=True, progress=True)
  if model_name == "efficientnet_b4":
    model = torchvision.models.efficientnet_b4(pretrained=True, progress=True)
  if model_name == "efficientnet_b5":
    model = torchvision.models.efficientnet_b5(pretrained=True, progress=True)
  if model_name == "efficientnet_b6":
    model = torchvision.models.efficientnet_b6(pretrained=True, progress=True)
  if model_name == "efficientnet_b7":
    model = torchvision.models.efficientnet_b7(pretrained=True, progress=True)
  # Freeze convolutional layers
  if freeze_conv_layers == True:
    for param in model.features.parameters():
      param.requires_grad = False
  # Modify the fully connected layers for the number of classes
  last_layer_input = model.classifier[1].in_features
  model.classifier[1] = nn.Linear(last_layer_input, num_classes)
  return model

# %% loading EfficientNet model
model = model_creator(model_name, num_classes)
print(model)
# Define loss function and optimizer
criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(model.parameters(), lr=learning_rate)

# Training loop
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
model.to(device)
print(f'deice={device}')
num_epochs = number_of_train_epochs

def train_one_epoch(model, optimizer, criterion, train_loader, device = device):
  model.train()
  running_loss = 0.0
  correct = 0
  total = 0
  for inputs, labels in train_loader:
      inputs, labels = inputs.to(device), labels.to(device)
      optimizer.zero_grad()
      outputs = model(inputs)
      loss = criterion(outputs, labels)
      loss.backward()
      optimizer.step()
      running_loss += loss.item()
      _, predicted = torch.max(outputs.data, 1)
      total += labels.size(0)
      correct += (predicted == labels).sum().item()

  train_accuracy = 100 * correct / total
  train_loss = running_loss / len(train_loader)
  return train_accuracy, train_loss

def test_one_epoch(model, optimizer, criterion, test_loader, device = device):
  model.eval()
  running_loss = 0.0
  correct = 0
  total = 0
  with torch.no_grad():
      for inputs, labels in test_loader:
          inputs, labels = inputs.to(device), labels.to(device)
          outputs = model(inputs)
          loss = criterion(outputs, labels)
          running_loss += loss.item()
          _, predicted = torch.max(outputs.data, 1)
          total += labels.size(0)
          correct += (predicted == labels).sum().item()

  test_accuracy = 100 * correct / total
  test_loss = running_loss / len(test_loader)
  return test_accuracy, test_loss

# %% training
train_losses = []
train_accuracies = []
test_losses = []
test_accuracies = []
print("Starting training")
for epoch in range(num_epochs):
    train_accuracy, train_loss = train_one_epoch(model, optimizer, criterion, test_loader, device)
    train_losses.append(train_loss)
    train_accuracies.append(train_accuracy)
    test_accuracy, test_loss = test_one_epoch(model, optimizer, criterion, test_loader, device)
    test_losses.append(test_loss)
    test_accuracies.append(test_accuracy)
    print(f"Epoch {epoch+1}/{num_epochs}, Train Loss: {train_loss:.2f}, Train Accuracy: {train_accuracy:.2f}%, Test Loss: {test_loss:.2f}, Test Accuracy: {test_accuracy:.2f}%")

# %% Plot accuracy
# Plotting
plt.figure(figsize=(10, 5))
plt.plot(train_losses, label='Train Loss')
plt.plot(test_losses, label='Test Loss')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.title(f'Training and Test Loss for {model_name}')
plt.legend()
plt.show()

plt.figure(figsize=(10, 5))
plt.plot(train_accuracies, label='Train Accuracy')
plt.plot(test_accuracies, label='Test Accuracy')
plt.xlabel('Epoch')
plt.ylabel('Accuracy')
plt.title(f'Training and Test Accuracy for {model_name}')
plt.legend()
plt.show()

# %% Calculate accuracy and Confusion matrix
model.eval()
running_loss = 0.0
correct = 0
total = 0
all_labels = []
all_predicted = []

with torch.no_grad():
    for inputs, labels in test_loader:
        inputs, labels = inputs.to(device), labels.to(device)
        outputs = model(inputs)
        loss = criterion(outputs, labels)
        running_loss += loss.item()
        _, predicted = torch.max(outputs.data, 1)
        total += labels.size(0)
        correct += (predicted == labels).sum().item()

        all_labels.extend(labels.cpu().numpy())
        all_predicted.extend(predicted.cpu().numpy())

test_accuracy = 100 * correct / total
test_loss = running_loss / len(test_loader)

# %% test. Final test
print(f"Result of {model_name} test:")
print(f"random accuracy = {100/num_classes}")
print(f"Test Accuracy: {test_accuracy}%")

# %% Confusion matrix
# Calculate confusion matrix
conf_matrix = confusion_matrix(all_labels, all_predicted)

# Assuming `labels` contains the class labels
labels = [f'Class {i}' for i in range(num_classes)]

# Plot confusion matrix
plt.figure(figsize=(8, 6))
sns.heatmap(conf_matrix, annot=True, cmap='Blues', fmt='g')
plt.xlabel('Predicted Value')
plt.ylabel('Actual Value')
plt.xticks(np.arange(num_classes) + 0.5, labels)
plt.yticks(np.arange(num_classes) + 0.5, labels)
plt.title(f'Confusion Matrix of {model_name} for side {side_to_use}')
plt.show()